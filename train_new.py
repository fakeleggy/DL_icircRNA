from SpliceAI_prostate.spliceai import *
from SpliceAI_prostate.utils import *
from SpliceAI_prostate.multi_gpu import *
from create_data_file import *


def clip_datapoints(X, Y, N_GPUS):
    # This function is necessary to make sure of the following:
    # Each time model_m.fit is called, the number of datapoints is a
    # multiple of N_GPUS. Failure to ensure this often results in crashes.
    rem = X.shape[0]%N_GPUS
    if rem != 0:
        return X[:-rem,:], [Y[t][:-rem] for t in range(1)]
    else:
        return X, [Y[t] for t in range(1)]

def SpliceAImodel(x_all,y_all,x_pd,y_pd,nt):
    # x_all, y_all are the input data generated by creat_data_file.py
    # x_pd is the input of prediction
    # nt = 80,400,1200,2000,10000
    L = 32
    N_GPUS = 2
    if nt == 80:
      W = np.asarray([[11], [11], [11], [11]])
      AR = np.asarray([[1], [1], [1], [1]])
      BATCH_SIZE = 18*N_GPUS
    elif nt == 400:
      W = np.asarray([[11], [11], [11], [11], [11], [11], [11], [11]])
      AR = np.asarray([[1], [1], [1], [1], [4], [4], [4], [4]])
      BATCH_SIZE = 18*N_GPUS
    elif nt == 1200:
      W = np.asarray([[11], [11], [11], [11], [11], [11], [11], [11], [11], [11], [11], [11]])
      AR = np.asarray([[1], [1], [1], [1], [4], [4], [4], [4], [10], [10], [10], [10]])
      BATCH_SIZE = 12*N_GPUS
    elif nt == 2000:
      W = np.asarray([[11], [11], [11], [11], [11], [11], [11], [11], [21], [21], [21], [21]])
      AR = np.asarray([[1], [1], [1], [1], [4], [4], [4], [4], [10], [10], [10], [10]])
      BATCH_SIZE = 12*N_GPUS
    elif nt == 10000:
      W = np.asarray([[11], [11], [11], [11], [11], [11], [11], [11], [21], [21], [21], [21], [41], [41], [41], [41]])
      AR = np.asarray([[1], [1], [1], [1], [4], [4], [4], [4], [10], [10], [10], [10], [25], [25], [25], [25]])
      BATCH_SIZE = 6*N_GPUS
    else:
      raise Exception("Invalid nt!")

    model = SpliceAI(L, W, AR)
    model_m = make_parallel(model, N_GPUS)
    model_m.compile(loss="categorical_crossentropy", optimizer='adam')
    print(model_m.summary())

    X_all_1h=x_all
    Y_all_1h = np.array(y_all)[np.newaxis,:,np.newaxis,:]
    Xc, Y = clip_datapoints(X_all_1h, Y_all_1h, N_GPUS)
    Yc=np.reshape(Y,(len(Y[0]),-1))
    model_m.fit(Xc, Yc, batch_size=BATCH_SIZE,epochs=20, verbose=1)

    test_y=np.array(y_pd)[np.newaxis,:,np.newaxis,:]
    Xpc, Ytc=clip_datapoints(x_pd,test_y,N_GPUS)
    Ytc=np.reshape(Ytc,(len(Ytc[0]),-1))
    Ypc = model_m.predict(Xpc, batch_size=BATCH_SIZE)
    #Ypc is the predict value, Ytc is true value
    return Ypc,Ytc


